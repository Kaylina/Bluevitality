#### 正则表达式元字符
```txt
\ 将下个字符标为特殊字符，或原义字符、或后向引用、八进制转义。如’n’匹配字符n。\n匹配换行
^ 匹配开始位置。如果设置了RegExp对象的Multiline属性，^也匹配‘\n’或‘\r’ 之后的位置             
$ 匹配结束位置。如果设置了RegExp对象的Multiline属性，$也匹配‘\n’或‘\r’ 之前的位置             
* 匹配前面的子表达式零或多次。如：zo* 匹配 "z" 及 "zoo"。 * 等价于{0,}。                      
+ 匹配前面的子表达式一或多次。如：’zo+’ 匹配"zo"或zoo"，但不匹配 "z"。+等价于{1,}             
? 匹配前面的子表达式零或一次。如："do(es)?" 可匹配 "do" 或 "does" 中的"do" 。?等价{0,1}       
{n} n是非负整数。匹配确定的n次。如：’o{2}’ 不匹配 "Bob" 中的 ‘o’，但能匹配"food"中的两个o     
{n,} n是非负整数。至少匹配n次。如：’o{2,}’ 不匹配 "Bob" 中的 ‘o’，但匹配"foood"中所有o        
{n,m} m和n均为非负整数且 n<=m 。最少匹配n次且最多匹配m次。"o{1,3}"匹配 "foooood"中的前3个
? 当其紧跟在任何1个其他限制符：*, +, ?, {n}, {n,}, {n,m}后时，匹配模式是非贪婪的(尽可能少的匹配字串)                   
. 匹配除"\n"之外的任何单个字符。要匹配包括‘\n’在内的任何字符，请使用象 ‘[.\n]’ 的模式。                             
(pattern) 匹配pattern并获取此匹配。所获取的匹配可从产生的Matches集合得到，在Visual Basic Scripting 中可用$0…$9 
(?:pattern) 匹配pattern但不获取它，是非获取匹配，即不会存储供以后使用。在用"|"组合模式各部分时很有用,如 ind(?:y¦ie) 
(?=pattern) 正向预查，在匹配pattern的串开始处匹配查找字串。(非获取匹配)。Win (?=95¦98¦2k) 匹配"Win 2k"的"Win"  
(?!pattern) 负向预查，在不匹配pattern的串开始处匹配查找字串。(非获取匹配)。Win (?!95¦98¦2k) 匹配"Win 3.1"的"Win"
x ¦ y 匹配 x 或 y。如：’z¦food’ 能匹配 "z" 或 "food"。’(z¦f)ood’ 则匹配 "zood" 或 "food"
[xyz] 字符集合。匹配所包含的任意一个字符。如： ‘[abc]’ 可以匹配 "plain" 中的 ‘a’。               
[^xyz] 负值字符集合。匹配未包含的任意字符。如： ‘[^abc]’ 可以匹配 "plain" 中的’p’。              
[a-z] 字符范围。匹配指定范围内的任意字符。如：’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。                   
[^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。如：’[^a-z]’ 可匹配任何不在 ‘a’到‘z’范围的任意字符
\b 匹配1个单词边界，其实就是指单词和空格间的位置。如：‘er\b’ 可匹配"never"的‘er’，但能匹配"verb"的’er’   
\B 匹配非单词边界。’er\B’ 能匹配 "verb" 中的 ‘er’，但不能匹配 "never" 中的 ‘er’                  
\cx 匹配由x指明的控制字符。如：\cM 匹配1个Ctl+M或回车。 x的值须为 A-Z 或 a-z 之1。否则将c视为一个原义的‘c’字符
\d 匹配1个数字字符。等价于 [0-9]。                                        
\D 匹配1个非数字字符。等价于 [^0-9]。                                     
\f 匹配1个换页符。等价于 \x0c 和 \cL。                                    
\n 匹配1个换行符。等价于 \x0a 和 \cJ。                                    
\r 匹配1个回车符。等价于 \x0d 和 \cM。                                    
\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 
\S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]                                                                 
\t 匹配1个制表符。等价于 \x09 和 \cI。                                                                        
\v 匹配1个垂直制表符。等价于 \x0b 和 \cK    
\w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’
\W 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]‘。  
\xn 匹配 n，其中 n 为16进制转义值。十六进制转义值必须为确定的2个数字长。如‘\x41’匹配"A"。’\x041’等价于’\x04’&"1"
\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。如：’(.)\1’ 匹配两个连续的相同字符
\n 标识1个8进制转义值或后向引用。若\n之前至少n个获取的子表达式则n为后向引用。否则若n为8进制数字0-7，则为1个8进制转义值
\nm 标识1个8进制转义值或1个后向引用。如果\nm之前至少有is preceded by at least nm 个获取得子表达式，则nm为后向引用
\nml 如果n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml                          
\un 匹配n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。如： \u00A9 匹配版权符号(?) 
```

#### POSIX 风格正则
```txt
[:space:]     空白字符       
[:alnum:]     数字及字母大小写
[:punct:]     所有标点       
[:alpha:]     大小写字母      
[:lower:]     小写字母       
[:upper:]     大写字母       
[:digit:]     所有数字       
```
#### 常用的反义代码
```txt
\W        匹配任意不是字母，数字，下划线，汉字的字符
\S        匹配任意不是空白符的字符
\D        匹配任意非数字的字符
\B        匹配不是单词开头或结束的位置
[^x]      匹配除了x以外的任意字符
[^aeiou]  匹配除了aeiou这几个字母以外的任意字符

Example:
\S+       匹配不包含空白符的字符串。
<a[^>]+>  匹配用尖括号括起来的以a开头的字符串。
```

`如：非字母开头且数字结尾：[^[:alpha:]]*[[:digit:]]`

#### 正则的贪婪与非贪婪
```
# 当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。
# 考虑这个表达式：a.*b，它将会匹配最长的以a开始，以b结束的字符串。
# 如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。
# 有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。
# 前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 ?
# 这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。

# a.*?b匹配最短的，以a开始，以b结束的字符串。
# 如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。

*?      重复任意次，但尽可能少重复
+?      重复1次或更多次，但尽可能少重复
??      重复0次或1次，但尽可能少重复
{n,m}?  重复n到m次，但尽可能少重复
{n,}?   重复n次以上，但尽可能少重复
```
#### 正向零宽断言的先行与后发
```txt
零宽度正预测先行断言:
(?=exp) ，它断言自身出现的位置的后面能匹配表达式exp
如 \b\w+(?=ing\b) 匹配以ing结尾的单词的前面部分(除ing以外的)，如I'm singing while you're dancing.会匹配sing和danc

零宽度正回顾后发断言
(?<=exp) 它断言自身出现的位置的前面能匹配表达式exp。如 (?<=\bre)\w+\b 匹配以re开头的单词的后半部分(除re以外的)
例如在查找reading a book时它匹配ading

假如想要给一个很长的数字中每三位间加一个逗号（当然是从右边加起了）
可以这样查找需要在前面和里面添加逗号的部分：((?<=\d)\d{3})*\b 用它对1234567890进行查找时结果是234567890。

这个例子同时使用了这两种断言：(?<=\s)\d+(?=\s) 匹配以空白符间隔的数字 (再次强调，不包括这些空白符)
```
#### 负向零宽断言的先行与后发
```txt
请详细分析表达式(?<=<(\w+)>).*(?=<\/\1>)，这个表达式最能表现零宽断言的真正用途。
如果想查找这样的单词：它里面有字母q且后面跟的不是u，我们可以尝试这样：\b\w*q[^u]\w*\b
\b\w*q[^u]\w*\b 匹配包含后面不是字母u的字母q的词。
但如果多做测试你会发现如果q出现在单词结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符！
所以若q是单词的最后1个字符的话，后面的[^u]将会匹配q后面的单词分隔符 (可能是空格，或是句号或其它的什么)
后面的\w*\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting！
负向零宽断言能解决这样的问题，因为它只匹配一个位置而且它并不消费任何字符！
现在我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b

零宽度负预测先行断言：
(?!exp) 断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字
\b((?!abc)\w)+\b 匹配不包含连续字符串abc的单词

零宽度正回顾后发断言：
同理我们可用 (?<!exp) 零宽度正回顾后发断言来断言此位置前面不能匹配表达式exp：
(?<![a-z])\d{7} 匹配前面不是小写字母的七位数字

一个更复杂的例子：
(?<=<(\w+)>).*(?=<\/\1>) 匹配不包含属性的简单HTML标签内里的内容
(<?(\w+)>)指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)，然后是.*(任意的字符串),最后是1个后缀(?=<\/\1>)
注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容
这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)

```
#### 零宽断言与懒惰匹配及平衡组
```txt　　　
(exp)           匹配exp,并捕获文本到自动命名的组里
(?<name>exp)    匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
(?:exp)         匹配exp,不捕获匹配的文本，也不给此分组分配组号
(?=exp)         匹配exp前面的位置
(?<=exp)        匹配exp后面的位置
(?!exp)         匹配后面跟的不是exp的位置
(?<!exp)        匹配前面不是exp的位置
(?#comment)	    这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读

注：要特别注意的是，零宽断言是不占用位置的，也就是说，匹配结果里是不会返回它的
```

#### Example
|Example|描述|
|:--|:--|
|<\s*h4[^>]*>(.*?)<\s*/\s*h4> 			|			匹配指定类型标签对及其内容 |
|<(.&#166;\n)*?>  			|  匹配所有标签对 |
|<\s*\w.*?>   | 		匹配所有开始标签 |
|<\s*\/\s*\w\s*.*?>|<\s*br\s*> 			|   	匹配所有结尾标签(包含<br>) |
|<\s*div.*?>   |  			匹配指定类型的开始标签 |
|<\s*\/\s*div\s*.*?>  		|  		匹配指定类型的结尾标签 |
|<\s*\/?\s*span\s*.*?>  	|			匹配指定类型的标签对 |
|<\s*\w*\s*style.*?>  		|			匹配指定属性的开始标签 |
|<\s*\w*\s*href\s*=\s*"?\s*([\w\s%#\/\.;:_-]*)\s*"?.*?>	|			匹配指定属性的开始标签 |
