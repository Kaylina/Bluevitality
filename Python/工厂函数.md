> 工厂函数：一个能够记住嵌套作用域的变量值的函数，尽管那个作用域已经不存在了  
> 它看上去像函数但实质上是类，当你调用它们时实际上是生成了该类型的实例，就像工厂生产货物一样

```python
#定义1个外部函数，它函数简单地生成并返回了嵌套的函数，却并不调用这个内嵌函数
>>> def maker(N):
        def action(X):
            return X**N
        return action  

#如果调用外部函数会得到1个生成的内嵌函数的引用
#此内嵌函数是通过运行内嵌def而创建的。若再调用外部得到的那个函数：
>>> f = maker(2)
>>> f(3)                    # 3的平方
9
>>> f(4)                    # 4的平方
16
>>> 
#它将调用内嵌函数，就是说maker函数内的名为action的函数。
#此时最不平凡的就是内嵌函数记住了2，即maker函数内变量N的值，尽管执行f时maker已返回了值并且退出。
#实际上在本地作用域的N被作为执行的状态信息保留了下来，我们返回其参数的平方运算。 

#如果再调用外层函数将得到新的有不同状态信息的嵌套函数！
#得到了一个参数的三次方而不是平方，但是最初的仍像往常一样是平方：
>>> g = maker(3)
>>> g(3)             # 3的3次方
27
>>> f(3)             # 3的2次方
9
>>> 
#这能奏效，是因为像这样对一个工厂函数的每次调用，都得到了自己的状态信息集合。
```

#### 这个例子中list工厂函数把一个元祖对象加工成了一个列表对象
```python
>>> a=(1,2,3,4)
>>> type(a)
<type 'tuple'>
>>> b=list(a)
>>> type(b)
<type 'list'>
>>> b
[1, 2, 3, 4]
```
